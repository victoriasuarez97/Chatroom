/** @license React v16.6.1
 * eslint-plugin-react-hooks.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

'use strict';function G(a){return"Identifier"===a.type?/^use[A-Z0-9].*$/.test(a.name):"MemberExpression"===a.type&&!a.computed&&G(a.property)?(a=a.object,"Identifier"===a.type&&"React"===a.name):!1}function I(a){return"Identifier"===a.type?!/^[a-z]/.test(a.name):!1}function M(a){for(;a;){var b=N(a);if(b&&(I(b)||G(b)))return!0;a=a.parent}return!1}
function N(a){if("FunctionDeclaration"===a.type||"FunctionExpression"===a.type&&a.id)return a.id;if("FunctionExpression"===a.type||"ArrowFunctionExpression"===a.type)return"VariableDeclarator"===a.parent.type&&a.parent.init===a?a.parent.id:"AssignmentExpression"===a.parent.type&&a.parent.right===a&&"="===a.parent.operator?a.parent.left:"Property"!==a.parent.type||a.parent.value!==a||a.parent.computed?"AssignmentPattern"!==a.parent.type||a.parent.right!==a||a.parent.computed?void 0:a.parent.left:a.parent.key}
function O(a){if("Identifier"===a.type)return a.name;if("MemberExpression"!==a.type||a.computed)throw Error("Unsupported node type: "+a.type);var b=O(a.object);a=O(a.property);return b+"."+a}function P(a){return"MemberExpression"!==a.type||"Identifier"!==a.object.type||"React"!==a.object.name||"Identifier"!==a.property.type||a.computed?a:a.property}
function R(a,b){var c=P(a);if("Identifier"!==c.type)return null;switch(c.name){case "useEffect":case "useLayoutEffect":case "useCallback":case "useMemo":return 0;case "useImperativeHandle":return 1;default:if(c===a&&b&&b.additionalHooks){a=void 0;try{a=O(c)}catch(d){if(/Unsupported node type/.test(d.message))return 0;throw d;}return b.additionalHooks.test(a)?0:-1}return-1}}
function S(a){var b=a.resolved;if(null==b||!Array.isArray(b.defs))return!1;b=b.defs[0];if(null==b||null==b.node.init)return!1;var c=b.node.init;if(null==c.callee)return!1;c=c.callee;"MemberExpression"!==c.type||"React"!==c.object.name||null==c.property||c.computed||(c=c.property);if("Identifier"!==c.type)return!1;b=b.node.id;return"useRef"===c.name&&"Identifier"===b.type||("useState"===c.name||"useReducer"===c.name)&&"ArrayPattern"===b.type&&2===b.elements.length&&Array.isArray(a.resolved.identifiers)&&
b.elements[1]===a.resolved.identifiers[0]?!0:!1}
function T(a,b){for(var c=[a],d=null;c.length;){d=c.shift();if("Identifier"===d.type&&d.name===b.name&&d.range[0]===b.range[0]&&d.range[1]===b.range[1])return d;if(d.range[0]<=b.range[0]&&d.range[1]>=b.range[1]){a=!0;var t=!1,y=void 0;try{for(var e=Object.entries(d)[Symbol.iterator](),n;!(a=(n=e.next()).done);a=!0){var z=n.value,h=z[1];"parent"!==z[0]&&(U(h)?(h.parent=d,c.push(h)):Array.isArray(h)&&h.forEach(function(a){U(a)&&(a.parent=d,c.push(a))}))}}catch(E){t=!0,y=E}finally{try{!a&&e.return&&
e.return()}finally{if(t)throw y;}}}}return null}function V(a){for(var b="",c=0;c<a.length;c++)b+=a[c],0===c&&2===a.length?b+=" and ":c===a.length-2&&2<a.length?b+=", and ":c<a.length-1&&(b+=", ");return b}function U(a){return"object"===typeof a&&null!==a&&!Array.isArray(a)&&"string"===typeof a.type}
module.exports={rules:{"rules-of-hooks":{create:function(a){var b=[],c=[];return{onCodePathSegmentStart:function(a){return c.push(a)},onCodePathSegmentEnd:function(){return c.pop()},onCodePathStart:function(){return b.push(new Map)},onCodePathEnd:function(c,t){function d(a){var f=d.cache,b=f.get(a.id);if(null===b){if(!h.has(a.id)){h.add(a.id);f=!0;b=!1;var g=void 0;try{for(var l=a.prevSegments[Symbol.iterator](),e;!(f=(e=l.next()).done);f=!0)d(e.value)}catch(B){b=!0,g=B}finally{try{!f&&l.return&&
l.return()}finally{if(b)throw g;}}}return 0}if(void 0!==b)return b;f.set(a.id,null);if(c.thrownSegments.includes(a))b=0;else if(0===a.prevSegments.length)b=1;else{b=0;l=!0;e=!1;var q=void 0;try{g=a.prevSegments[Symbol.iterator]();for(var r;!(l=(r=g.next()).done);l=!0)b+=d(r.value)}catch(B){e=!0,q=B}finally{try{!l&&g.return&&g.return()}finally{if(e)throw q;}}}a.reachable&&0===b?f.delete(a.id):f.set(a.id,b);return b}function e(a){var b=e.cache,f=b.get(a.id);if(null===f){if(!h.has(a.id)){h.add(a.id);
b=!0;f=!1;var g=void 0;try{for(var d=a.nextSegments[Symbol.iterator](),q;!(b=(q=d.next()).done);b=!0)e(q.value)}catch(B){f=!0,g=B}finally{try{!b&&d.return&&d.return()}finally{if(f)throw g;}}}return 0}if(void 0!==f)return f;b.set(a.id,null);if(c.thrownSegments.includes(a))f=0;else if(0===a.nextSegments.length)f=1;else{f=0;d=!0;q=!1;var r=void 0;try{g=a.nextSegments[Symbol.iterator]();for(var l;!(d=(l=g.next()).done);d=!0)f+=e(l.value)}catch(B){q=!0,r=B}finally{try{!d&&g.return&&g.return()}finally{if(q)throw r;
}}}b.set(a.id,f);return f}function n(a){var f=n.cache,b=f.get(a.id);if(null===b)return Infinity;if(void 0!==b)return b;f.set(a.id,null);if(0===a.prevSegments.length)b=1;else{b=Infinity;var g=!0,c=!1,d=void 0;try{for(var q=a.prevSegments[Symbol.iterator](),e;!(g=(e=q.next()).done);g=!0){var r=n(e.value);r<b&&(b=r)}}catch(W){c=!0,d=W}finally{try{!g&&q.return&&q.return()}finally{if(c)throw d;}}b+=1}f.set(a.id,b);return b}var z=b.pop();if(0!==z.size){var h=new Set;d.cache=new Map;e.cache=new Map;n.cache=
new Map;var E=e(c.initialSegment),m=N(t),J=M(t),F=m?I(m)||G(m):!1,w=Infinity,k=!0,A=!1,p=void 0;try{for(var v=c.finalSegments[Symbol.iterator](),C;!(k=(C=v.next()).done);k=!0){var H=C.value;if(H.reachable){var D=n(H);D<w&&(w=D)}}}catch(l){A=!0,p=l}finally{try{!k&&v.return&&v.return()}finally{if(A)throw p;}}k=!0;A=!1;p=void 0;try{for(var f=z[Symbol.iterator](),g;!(k=(g=f.next()).done);k=!0){var q=g.value,r=q[0],X=q[1];if(r.reachable){var Y=0===r.nextSegments.length?w<=n(r):w<n(r),Z=d(r)*e(r),u=h.has(r.id);
z=!0;v=!1;C=void 0;try{for(var L=X[Symbol.iterator](),Q;!(z=(Q=L.next()).done);z=!0){var x=Q.value;u&&a.report({node:x,message:'React Hook "'+a.getSource(x)+'" may be executed more than once. Possibly because it is called in a loop. React Hooks must be called in the exact same order in every component render.'});if(F){if(!u&&Z!==E){var aa='React Hook "'+a.getSource(x)+'" is called conditionally. React Hooks must be called in the exact same order in every component render.'+(Y?" Did you accidentally call a React Hook after an early return?":
"");a.report({node:x,message:aa})}}else if(!t.parent||"MethodDefinition"!==t.parent.type&&"ClassProperty"!==t.parent.type||t.parent.value!==t)if(m){var ba='React Hook "'+a.getSource(x)+'" is called in '+('function "'+a.getSource(m)+'" ')+"which is neither a React function component or a custom React Hook function.";a.report({node:x,message:ba})}else if("Program"!==t.type&&J){var ca='React Hook "'+a.getSource(x)+'" cannot be called inside a callback. React Hooks must be called in a React function component or a custom React Hook function.';
a.report({node:x,message:ca})}}}catch(l){v=!0,C=l}finally{try{!z&&L.return&&L.return()}finally{if(v)throw C;}}}}}catch(l){A=!0,p=l}finally{try{!k&&f.return&&f.return()}finally{if(A)throw p;}}}},CallExpression:function(a){if(G(a.callee)){var d=b[b.length-1],y=c[c.length-1],e=d.get(y);e||(e=[],d.set(y,e));e.push(a.callee)}}}}},"exhaustive-deps":{meta:{fixable:"code",schema:[{type:"object",additionalProperties:!1,properties:{additionalHooks:{type:"string"}}}]},create:function(a){function b(b){function d(a){var f=
!0,c=!1,e=void 0;try{for(var h=a.references[Symbol.iterator](),n;!(f=(n=h.next()).done);f=!0){var k=n.value;if(k.resolved&&E.has(k.resolved.scope)){var u=T(b,k.identifier);var m="MemberExpression"!==u.parent.type||u.parent.object!==u||"current"===u.parent.property.name||u.parent.computed||null!=u.parent.parent&&"CallExpression"===u.parent.parent.type&&u.parent.parent.callee===u.parent?u:u.parent;var t=O(m),x;if(x=z&&"Identifier"===m.type&&"MemberExpression"===m.parent.type&&!m.parent.computed&&"Identifier"===
m.parent.property.type&&"current"===m.parent.property.name){for(var p=k.from,v=!1;p.block!==b;)"function"===p.type&&(v=null!=p.block.parent&&"ReturnStatement"===p.block.parent.type),p=p.upper;x=v}x&&J.set(t,{reference:k,dependencyNode:m});if(!F.has(t)){var y=S(k);F.set(t,{isStatic:y,reference:k})}}}}catch(K){c=!0,e=K}finally{try{!f&&h.return&&h.return()}finally{if(c)throw e;}}f=!0;c=!1;e=void 0;try{for(var l=a.childScopes[Symbol.iterator](),w;!(f=(w=l.next()).done);f=!0)d(w.value)}catch(K){c=!0,e=
K}finally{try{!f&&l.return&&l.return()}finally{if(c)throw e;}}}function y(a,b,c,e){return 0===a.size?null:(1<a.size?"":b+" ")+c+" "+(1<a.size?"dependencies":"dependency")+": "+V(Array.from(a).sort().map(function(a){return"'"+a+"'"}))+(". Either "+e+" "+(1<a.size?"them":"it")+" or remove the dependency array.")}if(("FunctionExpression"===b.type||"ArrowFunctionExpression"===b.type)&&"CallExpression"===b.parent.type){var e=R(b.parent.callee,c);if(b.parent.arguments[e]===b){var n=b.parent.callee,z=P(n).name.endsWith("Effect"),
h=b.parent.arguments[e+1];if(h){e=a.getScope();for(var E=new Set,m=e.upper;m;){E.add(m);if("function"===m.type)break;m=m.upper}if(m){var J=new Map,F=new Map;d(e);J.forEach(function(b,c){var f=b.dependencyNode;b=b.reference.resolved.references;for(var e=!1,g=0;g<b.length;g++){var d=b[g].identifier.parent;if(null!=d&&"MemberExpression"===d.type&&!d.computed&&"Identifier"===d.property.type&&"current"===d.property.name&&"AssignmentExpression"===d.parent.type&&d.parent.left===d){e=!0;break}}e||a.report({node:f.parent.property,
message:"Accessing '"+c+".current' during the effect cleanup will likely read a different ref value because by this time React has already updated the ref. If this ref is managed by React, store "+("'"+c+".current' in a variable inside ")+"the effect itself and refer to that variable from the cleanup function."})});var w=[];"ArrayExpression"!==h.type?a.report({node:h,message:"React Hook "+a.getSource(n)+" has a second argument which is not an array literal. This means we can't statically verify whether you've passed the correct dependencies."}):
h.elements.forEach(function(b){if(null!==b)if("SpreadElement"===b.type)a.report({node:b,message:"React Hook "+a.getSource(n)+" has a spread element in its dependency array. This means we can't statically verify whether you've passed the correct dependencies."});else{var c=void 0;try{c=O(b)}catch(q){if(/Unsupported node type/.test(q.message)){"Literal"===b.type?"string"===typeof b.value?a.report({node:b,message:"The "+b.raw+" string literal is not a valid dependency because it never changes. Did you mean to "+
("include "+b.value+" in the array instead?")}):a.report({node:b,message:"The '"+b.raw+"' literal is not a valid dependency because it never changes. You can safely remove it."}):a.report({node:b,message:"React Hook "+a.getSource(n)+" has a complex expression in the dependency array. Extract it to a separate variable so it can be statically checked."});return}throw q;}w.push({key:c,node:b})}});var k=[],A=new Set,p=new Set,v=new Set,C=Array.from(F.keys()),H=!1;w.forEach(function(a){var b=a.key;C.some(function(a){return a===
b||a.startsWith(b+".")})?-1===k.indexOf(b)?k.push(b):A.add(b):p.add(b)});F.forEach(function(b,c){var f=b.isStatic;b=b.reference;b.writeExpr&&(H=!0,a.report({node:b.writeExpr,message:"Assignments to the '"+c+"' variable from inside a React "+a.getSource(n)+" Hook will not persist between re-renders. If it's only needed by this Hook, move the variable inside it. Alternatively, declare a ref with the useRef Hook, and keep the mutable value in its 'current' property."}));k.some(function(a){return c===
a||c.startsWith(a+".")})||f||(k.push(c),v.add(c))});(function(){if(0===w.length)return!0;var a=w.map(function(a){return a.key}),b=a.slice().sort();return a.join(",")===b.join(",")})()&&k.sort();if(0!==A.size+v.size+p.size&&!H){e="";if(0<p.size){var D=null;Array.from(p.keys()).forEach(function(a){null===D&&a.endsWith(".current")&&(D=a)});null!==D&&(e=" Mutable values like '"+D+"' aren't valid dependencies because their mutation doesn't re-render the component.")}a.report({node:h,message:"React Hook "+
a.getSource(n)+" has "+(y(v,"a","missing","include")||y(p,"an","unnecessary","exclude")||y(A,"a","duplicate","omit"))+e,fix:function(a){return a.replaceText(h,"["+k.join(", ")+"]")}})}}}}}}var c={additionalHooks:a.options&&a.options[0]&&a.options[0].additionalHooks?new RegExp(a.options[0].additionalHooks):void 0};return{FunctionExpression:b,ArrowFunctionExpression:b}}}}};
